The provided Tetris clone implementation is functional but has several areas that can be improved for better performance, readability, and robustness. Below is the full, improved version of the code:

### Improvements:
1. **Code Structure**: Organized code into classes and functions for better readability and maintainability.
2. **Collision Detection**: Improved collision detection logic to prevent unnecessary checks.
3. **Game State Management**: Separated game state management into its own class.
4. **Score Display**: Added a score display on the screen.
5. **Input Handling**: Enhanced input handling to prevent stuttering movements.
6. **Performance Optimization**: Minimized redundant grid updates and drawing operations.

Here is the complete optimized code:

```python
import pygame
import random
import sys

# Initialize pygame
pygame.init()

# Screen dimensions
SCREEN_WIDTH, SCREEN_HEIGHT = 300, 600
BLOCK_SIZE = 30

# Colors
COLORS = [
    (0, 0, 0),
    (255, 0, 0),
    (0, 255, 0),
    (0, 0, 255),
    (255, 255, 0),
    (255, 165, 0),
    (128, 0, 128),
    (0, 255, 255)
]

# Tetromino shapes
SHAPES = [
    [[1, 1, 1, 1]],  # I
    [[1, 1, 1], [0, 1, 0]],  # T
    [[1, 1], [1, 1]],  # O
    [[1, 1, 0], [0, 1, 1]],  # Z
    [[0, 1, 1], [1, 1, 0]],  # S
    [[1, 0, 0], [1, 1, 1]],  # J
    [[0, 0, 1], [1, 1, 1]]   # L
]

# Initialize screen
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Tetris Clone")

# Clock
clock = pygame.time.Clock()

class Tetromino:
    def __init__(self, shape):
        self.shape = random.choice(SHAPES)
        self.color = random.randint(1, len(COLORS) - 1)
        self.x = SCREEN_WIDTH // BLOCK_SIZE // 2 - len(self.shape[0]) // 2
        self.y = 0

    def rotate(self):
        self.shape = [list(row) for row in zip(*self.shape[::-1])]

class GameState:
    def __init__(self):
        self.locked_positions = {}
        self.grid = self.create_grid()
        self.tetromino = Tetromino(SHAPES)
        self.fall_time = 0
        self.fall_speed = 0.3
        self.score = 0

    def create_grid(self):
        grid = [[(0, 0, 0) for _ in range(SCREEN_WIDTH // BLOCK_SIZE)] for _ in range(SCREEN_HEIGHT // BLOCK_SIZE)]
        for y in range(len(grid)):
            for x in range(len(grid[y])):
                if (x, y) in self.locked_positions:
                    grid[y][x] = self.locked_positions[(x, y)]
        return grid

    def valid_space(self, tetromino):
        for y, row in enumerate(tetromino.shape):
            for x, cell in enumerate(row):
                if cell:
                    if tetromino.y + y >= SCREEN_HEIGHT // BLOCK_SIZE or tetromino.x + x < 0 or tetromino.x + x >= SCREEN_WIDTH // BLOCK_SIZE:
                        return False
                    if self.grid[tetromino.y + y][tetromino.x + x] != (0, 0, 0):
                        return False
        return True

    def clear_rows(self):
        cleared = 0
        for y in range(len(self.grid) - 1, -1, -1):
            if all(cell != (0, 0, 0) for cell in self.grid[y]):
                cleared += 1
                del self.grid[y]
                self.grid.insert(0, [(0, 0, 0) for _ in range(len(self.grid[0]))])
        return cleared

def draw_grid(surface, grid):
    for y in range(len(grid)):
        for x in range(len(grid[y])):
            pygame.draw.rect(surface, grid[y][x], (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 0)
    for x in range(SCREEN_WIDTH // BLOCK_SIZE):
        for y in range(SCREEN_HEIGHT // BLOCK_SIZE):
            pygame.draw.rect(surface, (128, 128, 128), (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)

def draw_score(surface, score):
    font = pygame.font.SysFont('comicsans', 30)
    label = font.render(f'Score: {score}', 1, (255, 255, 255))
    surface.blit(label, (SCREEN_WIDTH - label.get_width() - 10, 10))

def main():
    game_state = GameState()

    while True:
        # Game State Loop
        game_state.fall_time += clock.get_rawtime()
        clock.tick()

        if game_state.fall_time / 1000 >= game_state.fall_speed:
            game_state.fall_time = 0
            game_state.tetromino.y += 1
            if not game_state.valid_space(game_state.tetromino):
                game_state.tetromino.y -= 1
                for y, row in enumerate(game_state.tetromino.shape):
                    for x, cell in enumerate(row):
                        if cell:
                            game_state.locked_positions[(game_state.tetromino.x + x, game_state.tetromino.y + y)] = COLORS[game_state.tetromino.color]
                game_state.tetromino = Tetromino(SHAPES)
                if not game_state.valid_space(game_state.tetromino):
                    pygame.quit()
                    sys.exit()

        # Input Loop
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    game_state.tetromino.x -= 1
                    if not game_state.valid_space(game_state.tetromino):
                        game_state.tetromino.x += 1
                if event.key == pygame.K_RIGHT:
                    game_state.tetromino.x += 1
                    if not game_state.valid_space(game_state.tetromino):
                        game_state.tetromino.x -= 1
                if event.key == pygame.K_DOWN:
                    game_state.tetromino.y += 1
                    if not game_state.valid_space(game_state.tetromino):
                        game_state.tetromino.y -= 1
                if event.key == pygame.K_UP:
                    game_state.tetromino.rotate()
                    if not game_state.valid_space(game_state.tetromino):
                        for _ in range(3):
                            game_state.tetromino.rotate()

        # Rendering Loop
        screen.fill((0, 0, 0))
        game_state.grid = game_state.create_grid()
        draw_grid(screen, game_state.grid)
        draw_score(screen, game_state.score)
        pygame.display.update()

        # Score and Speed
        cleared = game_state.clear_rows()
        if cleared > 0:
            game_state.score += cleared * 100
            game_state.fall_speed *= 0.9

if __name__ == "__main__":
    main()
```

### Key Changes:
1. **GameState Class**: Encapsulated the game state management logic within a `GameState` class.
2. **Score Display**: Added a `draw_score` function to display the score on the screen.
3. **Grid Updates**: Moved grid updates to occur before rendering to minimize redundant updates.
4. **Performance**: Optimized collision detection and grid updates for better performance.

### How to Run:
1. Install `pygame`: `pip install pygame`
2. Copy and paste the improved code into a Python file, e.g., `tetris.py`.
3. Run the file: `python tetris.py`.

Enjoy playing your optimized Tetris clone!