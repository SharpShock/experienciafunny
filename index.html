```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Clone</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: black;
        }
        canvas {
            border: 1px solid white;
        }
    </style>
</head>
<body>
    <canvas id="tetris" width="300" height="600"></canvas>
    <script>
        // Constants
        const SCREEN_WIDTH = 300;
        const SCREEN_HEIGHT = 600;
        const BLOCK_SIZE = 30;
        const GRID_WIDTH = SCREEN_WIDTH / BLOCK_SIZE;
        const GRID_HEIGHT = SCREEN_HEIGHT / BLOCK_SIZE;

        // Colors
        const BLACK = '#000000';
        const WHITE = '#FFFFFF';
        const GRAY = '#808080';
        const COLORS = [
            '#00FFFF',  // I - Cyan
            '#0000FF',  // J - Blue
            '#FFA500',  // L - Orange
            '#FFFF00',  // O - Yellow
            '#00FF00',  // S - Green
            '#800080',  // T - Purple
            '#FF0000'   // Z - Red
        ];

        // Tetrimino shapes
        const SHAPES = [
            [[1, 1, 1, 1]],  // I
            [[1, 0, 0], [1, 1, 1]],  // J
            [[0, 0, 1], [1, 1, 1]],  // L
            [[1, 1], [1, 1]],  // O
            [[0, 1, 1], [1, 1, 0]],  // S
            [[0, 1, 0], [1, 1, 1]],  // T
            [[1, 1, 0], [0, 1, 1]]   // Z
        ];

        const canvas = document.getElementById('tetris');
        const ctx = canvas.getContext('2d');

        class Tetrimino {
            constructor() {
                this.shape_idx = Math.floor(Math.random() * SHAPES.length);
                this.shape = SHAPES[this.shape_idx];
                this.color = COLORS[this.shape_idx];
                this.x = Math.floor(GRID_WIDTH / 2 - this.shape[0].length / 2);
                this.y = 0;
            }

            rotate() {
                const rows = this.shape.length;
                const cols = this.shape[0].length;
                const rotated = new Array(cols).fill(0).map(() => new Array(rows).fill(0));

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        rotated[c][rows - 1 - r] = this.shape[r][c];
                    }
                }

                return rotated;
            }

            draw() {
                for (let r = 0; r < this.shape.length; r++) {
                    for (let c = 0; c < this.shape[0].length; c++) {
                        if (this.shape[r][c]) {
                            ctx.fillStyle = this.color;
                            ctx.fillRect((this.x + c) * BLOCK_SIZE, (this.y + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                            ctx.strokeStyle = WHITE;
                            ctx.strokeRect((this.x + c) * BLOCK_SIZE, (this.y + r) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        }
                    }
                }
            }
        }

        class Game {
            constructor() {
                this.grid = new Array(GRID_HEIGHT).fill(0).map(() => new Array(GRID_WIDTH).fill(0));
                this.current_piece = new Tetrimino();
                this.next_piece = new Tetrimino();
                this.game_over = false;
                this.score = 0;
                this.level = 1;
                this.fall_speed = 500;  // milliseconds
                this.fall_time = 0;
                this.last_time = 0;
                this.font = '20px Arial';
            }

            reset() {
                this.grid = new Array(GRID_HEIGHT).fill(0).map(() => new Array(GRID_WIDTH).fill(0));
                this.current_piece = new Tetrimino();
                this.next_piece = new Tetrimino();
                this.game_over = false;
                this.score = 0;
                this.level = 1;
                this.fall_speed = 500;
            }

            valid_position(shape, x, y) {
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[0].length; c++) {
                        if (shape[r][c]) {
                            if (x + c < 0 || x + c >= GRID_WIDTH || y + r >= GRID_HEIGHT || (y + r >= 0 && this.grid[y + r][x + c])) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            merge_piece() {
                for (let r = 0; r < this.current_piece.shape.length; r++) {
                    for (let c = 0; c < this.current_piece.shape[0].length; c++) {
                        if (this.current_piece.shape[r][c]) {
                            if (this.current_piece.y + r < 0) {
                                this.game_over = true;
                                return;
                            }
                            this.grid[this.current_piece.y + r][this.current_piece.x + c] = this.current_piece.color;
                        }
                    }
                }
            }

            clear_lines() {
                let lines_cleared = 0;
                for (let r = GRID_HEIGHT - 1; r >= 0; r--) {
                    if (this.grid[r].every(cell => cell !== 0)) {
                        lines_cleared++;
                        this.grid.splice(r, 1);
                        this.grid.unshift(new Array(GRID_WIDTH).fill(0));
                    }
                }

                if (lines_cleared > 0) {
                    this.score += this.calculate_score(lines_cleared);
                    this.level = Math.floor(this.score / 1000) + 1;
                    this.fall_speed = Math.max(50, 500 - (this.level - 1) * 50);
                }
            }

            calculate_score(lines) {
                const scores = {1: 100, 2: 300, 3: 500, 4: 800};
                return scores[lines] * this.level;
            }

            update(dt) {
                if (this.game_over) {
                    return;
                }

                this.fall_time += dt;
                if (this.fall_time >= this.fall_speed) {
                    this.fall_time = 0;
                    if (this.valid_position(this.current_piece.shape, this.current_piece.x, this.current_piece.y + 1)) {
                        this.current_piece.y += 1;
                    } else {
                        this.merge_piece();
                        this.clear_lines();
                        this.current_piece = this.next_piece;
                        this.next_piece = new Tetrimino();
                    }
                }
            }

            draw() {
                // Draw grid background
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        ctx.fillStyle = this.grid[r][c] || GRAY;
                        ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        ctx.strokeStyle = WHITE;
                        ctx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                    }
                }

                // Draw current piece
                this.current_piece.draw();

                // Draw game info
                ctx.fillStyle = WHITE;
                ctx.font = this.font;
                ctx.fillText(`Score: ${this.score}`, 5, SCREEN_HEIGHT - 50);
                ctx.fillText(`Level: ${this.level}`, 5, SCREEN_HEIGHT - 25);

                if (this.game_over) {
                    ctx.fillText('GAME OVER! Press R to restart', SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT / 2 - 10);
                }
            }
        }

        const game = new Game();

        function handleInput(event) {
            if (!game.game_over) {
                if (event.key === 'ArrowLeft') {
                    if (game.valid_position(game.current_piece.shape, game.current_piece.x - 1, game.current_piece.y)) {
                        game.current_piece.x -= 1;
                    }
                } else if (event.key === 'ArrowRight') {
                    if (game.valid_position(game.current_piece.shape, game.current_piece.x + 1, game.current_piece.y)) {
                        game.current_piece.x += 1;
                    }
                } else if (event.key === 'ArrowDown') {
                    if (game.valid_position(game.current_piece.shape, game.current_piece.x, game.current_piece.y + 1)) {
                        game.current_piece.y += 1;
                    }
                } else if (event.key === 'ArrowUp') {
                    const rotated = game.current_piece.rotate();
                    if (game.valid_position(rotated, game.current_piece.x, game.current_piece.y)) {
                        game.current_piece.shape = rotated;
                    }
                } else if (event.key === ' ') {
                    // Hard drop
                    while (game.valid_position(game.current_piece.shape, game.current_piece.x, game.current_piece.y + 1)) {
                        game.current_piece.y += 1;
                    }
                    game.merge_piece();
                    game.clear_lines();
                    game.current_piece = game.next_piece;
                    game.next_piece = new Tetrimino();
                }
            } else if (event.key === 'r') {
                game.reset();
            }
        }

        function gameLoop(timestamp) {
            const dt = timestamp - (game.last_time || timestamp);
            game.last_time = timestamp;

            game.update(dt);
            ctx.clearRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
            game.draw();

            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', handleInput);
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
```

### Improvements and Fixes:

1. **Language Conversion**: Converted the code from Python to JavaScript/HTML/CSS for compatibility with web browsers.

2. **Game Loop**: Used `requestAnimationFrame` for smoother animation and better performance.

3. **Event Handling**: Added event listeners for keyboard input instead of using Pygame's event handling.

4. **Canvas Rendering**: Utilized the HTML5 Canvas API for rendering the game grid and pieces.

5. **Score Calculation**: Fixed the score calculation to ensure it updates correctly based on the number of lines cleared.

6. **Game Over Handling**: Added a restart functionality when the game is over by pressing 'R'.

7. **Styling**: Added basic CSS styling to center the canvas and set a black background.

### Features:
- Piece movement (left, right, down)
- Piece rotation
- Hard drop (spacebar)
- Line clearing and scoring
- Level progression with increasing speed
- Game over detection and restart functionality

### How to Play:
- Use LEFT and RIGHT arrow keys to move the piece horizontally
- Use UP arrow to rotate the piece
- Use DOWN arrow to move the piece down faster
- Press SPACE to instantly drop the piece
- When game over, press R to restart

This version maintains all the core mechanics of Tetris while being optimized for web browsers. It provides a smooth and responsive gaming experience.